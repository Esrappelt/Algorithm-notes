
## 基本框架

```
int array[] = {1,2,3,3,4,5,6};
int bs(int left,int right,int key) {
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if(array[mid ? key) right = mid - 1;
        else left = mid + 1;
    }
    return ?;
}
```

## 1. 查找第一个与key相等的元素

```
array[mid] >= key,return left;
```

## 2. 查找最后一个与key相等的元素

```
array[mid] <= key,return right;
```

## 3. 查找第一个大于key的元素

```
array[mid] > key,return left;
```

## 4. 查找最后一个小于等于key的元素

```
array[mid] > key,return right;
```

## 5. 查找第一个大于等于key的元素

```
array[mid] >= key,return left;
```

## 6. 查找最后一个小于key的元素

```
array[mid] >= key,return right;
```
## 7. 查找第一个小于key的元素
```
array[mid] < key,return left;
```
## 8. 查找最后一个大于等于key的元素
```
array[mid] < key,return right;
```
## 9. 查找第一个小于等于key的元素
```
array[mid] <= key,return left;
```
## 10. 查找最后一个大于key的元素
```
array[mid] <= key,return right;
```
## 总结规律
1. 先判断返回left还是right
    1. 如果是要查找第一个与key之间的关系，返回left
    2. 如果是要查找最后一个与Key之间的关系,返回right
2. 判断array[mid]与key之间的关系
    1. 查找第一个大于和查找最后一个小于等于相对应
    2. 查找第一个大于等于和查找最后一个小于相对应
    3. 查找第一个小于和查找最后一个大于等于相对应
    4. 查找第一个小于等于和查找最后一个大于相对应
    5. 查找第一个与key相等即用>=
    6. 查找最后一个与key相等即用<=
3. 记忆
    1. 第一个>: array[mid] > key
    2. 第一个>=: array[mid] >= key
    3. 第一个< :array[mid] < key
    4. 第一个<=: array[mid] <= key
    5. 最后一个是第一个相反的对应

## c++二分搜索函数
#### 1.lower_bound()
1. 作用：查找第一个大于或等于key的元素
2. 使用

```
vector<int> array = {1,2,3,3,4,5,6};
int key = 3;
int it = lower_bound(array.begin(),array.end(),key) - array.begin();
//it是返回元素的下标

//it != array.size()是判断有没有找到大于或等于key的元素，array[it] == key是判断这个元素是否是等于关系，否则就是大于关系。一般都是找的等于关系
if(it != array.size() && array[it] == key) {
    //则找到了这个值
    cout << it << endl;
}
```
#### 2.upper_bound()
1. 作用：查找第一个大于key的元素
2. 使用

```
vector<int> array = {1,2,3,3,4,5,6};
int key = 3;
int i = upper_bound(array.begin(),array.end()) - array.begin();
f(i != array.size() && array[i] == key) {
    //则找到了这个值
    cout << i << endl;//在这里i = 4
}
```


