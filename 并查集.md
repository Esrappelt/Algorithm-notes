## 并查集的作用
要解决的是整幅图的连通性问题。比如随意给你两个点，让你判断它们是否连通，或者问你整幅图一共有几个连通分支，也就是被分成了几个互相独立的块。像畅通工程这题，问还需要修几条路，实质就是求有几个连通分支。

## 并查集大概思路
若A和B是好朋友，而B和C是好朋友，那么A和C也即将成为好朋友。它是这样这样存储的：C的直接上级的B，而B的直接上级为C，那么这样就会形成一条链，从而形成一个朋友圈。而现在D和E是好朋友，但是和A、B、C都不是好朋友，那么D和E又形成一个朋友圈，那么这个朋友圈把它成为连通分支的个数。


那么一个朋友圈就有一个领头人，怎么确定领头人以及它的朋友呢：

```
int parent[1000];
int find(int x) {
    int r = x;
    while(r != parent[r])//它的上级不是领头人
        r = parent[r];/继续找
    return r;
}

```
找到领头人后，再加入朋友圈:

```
void join(int a,int b) {
    int x = find(a),y = find(b);//找到各自的领头人
    //如果他俩有关系，那么直接合并
    if(x != y) parent[y] = x;
}

```

最后，关于路径压缩：（让每一个人都成为领头人的直接下级）

```
int find(int x) {
    int r = x;
    while(r != parent[r]) r = parent[r];
    int k = parent[x],j;
    while( k != r ) {//让k的上级直接成为上司r
        j = parent[k];
        parent[k] = r;
        k = j;
    }
    return r;
}
```
最后，关于并查集的初始化:
路径要初始化为：自己是自己的上级
```
for(int i = 1; i <= n; i++) parent[i] = i;
```


## 并查集求连通分量

由于初始化了自己的上级是自己，那么经过一系列的关系合并后，如果自己的上级还是自己，那么自己就是一个朋友圈的领头人，那么只需要记录领头人有多少个，即就是连通分量的个数
```
int num = 0;//连通分量
 for(int i = 1; i <= n; i++) {
        if(find(i) == i) {
            num++;
        }
 }
```

其次，还可以记录每一个朋友圈有多少个人：

```
int ans[1000] = {0};
for(int i = 1; i <= n; i++) {
        pre = find(i);
        if(pre == i) num++;
        ans[pre]++;
}
//输出朋友圈的个数以及每一个朋友圈的人数
for(int i = 0; i < num; i++) printf("%d%c",ans[i],i < num - 1 ? ' ' : '\n');
```



## 并查集带权值




